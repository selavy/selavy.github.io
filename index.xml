
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
 <channel>
   <title>c&#39;est la vie</title>
   <link>https://selavy.github.io/</link>
   <description>Recent content on c&#39;est la vie</description>
   <generator>Hugo -- gohugo.io</generator>
   <language>en-us</language>
   <lastBuildDate>Sat, 19 Jan 2019 00:00:00 +0000</lastBuildDate>
   
       <atom:link href="https://selavy.github.io/index.xml" rel="self" type="application/rss+xml" />
   
   
     <item>
       <title>Programming Pearls: Chapter 11</title>
       <link>https://selavy.github.io/posts/prog-pearls-ch11/</link>
       <pubDate>Tue, 26 Feb 2019 19:32:27 -0800</pubDate>
       
       <guid>https://selavy.github.io/posts/prog-pearls-ch11/</guid>
       <description>&lt;p&gt;Problems from Column #11: Sorting&lt;/p&gt;
&lt;h1 id=&#34;lessons-from-programming-pearls&#34;&gt;Lessons from Programming Pearls:&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Work on the right problem.&lt;/li&gt;
&lt;li&gt;Explore the design space of solutions.&lt;/li&gt;
&lt;li&gt;Look at the data.&lt;/li&gt;
&lt;li&gt;Use the back of the envelope.&lt;/li&gt;
&lt;li&gt;Exploit symmetry&lt;/li&gt;
&lt;li&gt;Design with components.&lt;/li&gt;
&lt;li&gt;Build prototypes.&lt;/li&gt;
&lt;li&gt;Make tradeoffs when you have to.&lt;/li&gt;
&lt;li&gt;Keep it simple.&lt;/li&gt;
&lt;li&gt;Strive for elegance.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;First implementation of quicksort:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;I&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; is_partitioned(I begin, I end, I mid, C cmp) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (begin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; end) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;cmp(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;begin&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;mid)) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; false;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; true;
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;I&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
I partition(I begin, I end) {
    &lt;span style=&#34;color:#75715e&#34;&gt;// partition [begin, end) around *begin -- NOTE: explore the other partition strategies
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; lo &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; hi &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; end &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (lo &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; hi) {
        &lt;span style=&#34;color:#75715e&#34;&gt;// invariant: [begin + 1, lo ) &amp;lt;= *begin
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// invariant: (hi       , end) &amp;gt;= *begin
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        assert(is_partitioned(begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, lo , begin, std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;less_equal&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;{}));
        assert(is_partitioned(hi    &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, end, begin, std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;greater_equal&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;{}));

        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;lo &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;begin)) {
            &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;lo;
        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;hi &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;begin)) {
            &lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;hi;
        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
            std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;iter_swap(lo&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;, hi&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;);
        }

        assert(is_partitioned(begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, lo , begin, std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;less_equal&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;{}));
        assert(is_partitioned(hi    &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, end, begin, std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;greater_equal&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;{}));
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; mid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lo &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;begin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;lo) {
        mid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lo;
    }
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;iter_swap(begin, mid);

    assert(is_partitioned(begin  , mid, mid, std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;less_equal&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;{}));
    assert(is_partitioned(mid &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, end, mid, std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;greater_equal&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;{}));

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; mid;
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;I&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; qsort(I begin, I end) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; end &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; begin;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (count &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; mid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; partition(begin, end);
    qsort(begin, mid);
    qsort(mid &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, end);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note to self: don&amp;rsquo;t get lazy. Was easy to establish the loop invariants for partition(), but I then took too much time correctly setting mid. Just slow down to work it out.&lt;/p&gt;
&lt;p&gt;Pretty cool that it&amp;rsquo;s easy with C++14 generic lambdas to use std::is_partitioned(). My tests cases looked like:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;TEST_CASE(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Partition Tests&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[partition]&amp;#34;&lt;/span&gt;) {
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; tests &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
        { &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt; },
        { &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; },
        { &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; },
        { &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; },
        { &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; },
    };

    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; vs : tests) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; mid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ch11&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;partition2(vs.begin(), vs.end());
        REQUIRE(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;is_partitioned(vs.begin(), vs.end(), [mid](&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; x) { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;mid; }) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; true);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note that in C++ you can still do it with decltype, it&amp;rsquo;s just ugly:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;REQUIRE(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;is_partitioned(vs.begin(), vs.end(), [mid](&lt;span style=&#34;color:#66d9ef&#34;&gt;decltype&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;vs.begin()) x) { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;mid; }) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; true);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;But probably the better option is:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Iter&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; IsPartitioned(Iter begin, Iter end) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; ValueType &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;iterator_traits&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Iter&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;value_type;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;is_partitioned(begin &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, end, [begin](ValueType x) { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;begin; });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Another version of partition:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;I&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
I partition(I begin, I end) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; lo &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; begin;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; hi &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; end;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (;;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;do&lt;/span&gt; { &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;lo; } &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (lo &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; end &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;lo &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;begin);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;do&lt;/span&gt; { &lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;hi; } &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (            &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;hi &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;begin);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;(lo &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; hi)) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
        }
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;iter_swap(lo, hi);
    }
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;iter_swap(begin, hi);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; hi;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;problem-1&#34;&gt;Problem #1&lt;/h1&gt;
&lt;p&gt;Like any other powerful tool, sorting is often used when it shouldn&amp;rsquo;t be and not used when it should be. Explain how sorting could be overused or underused when calculating the following statistics of an array of &lt;em&gt;n&lt;/em&gt; floating point numbers: minimum, maximum, mean, median, and mode.&lt;/p&gt;
&lt;p&gt;minimum, maximum, mode, and mean can all be calculated online so no sorting needed. Median can be calculated with the quickselect algorithm or with 2 heaps, but sorting isn&amp;rsquo;t a completely unreasonable implementation.&lt;/p&gt;
&lt;p&gt;Median with 2 heaps algorithm: one min-heap, one max-heap; &lt;code&gt;len(heap1) - len(heap2) &amp;lt;= 1&lt;/code&gt;, i.e. there are half of the elements in each heap (for odd number of elements, the extra element can go in either).&lt;/p&gt;
&lt;p&gt;Very, very simple implementation of mode:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;calc_mode&lt;/span&gt;(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; vs) {
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;map&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; m;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; v : vs) {
        m[v]&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; it &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;max_element(m.begin(), m.end(), [](&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; x, &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; y) { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; x.second &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; y.second; });
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; it&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;first;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;calc_mean&lt;/span&gt;(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; vs) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;accumulate(vs.begin(), vs.end(), &lt;span style=&#34;color:#ae81ff&#34;&gt;0.&lt;/span&gt;);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; sum &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; vs.size();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;problem-2&#34;&gt;Problem #2&lt;/h1&gt;
&lt;p&gt;Speed up Lomuto&amp;rsquo;s partition scheme by using x[l] as a sentinel. Show how this scheme allows you to remove the &lt;em&gt;swap&lt;/em&gt; after the loop&lt;/p&gt;
&lt;h1 id=&#34;problem-3&#34;&gt;Problem #3&lt;/h1&gt;
&lt;p&gt;How could you experiment to find the best value of &lt;em&gt;cutoff&lt;/em&gt; on a particular system?&lt;/p&gt;
&lt;h1 id=&#34;problem-4&#34;&gt;Problem #4&lt;/h1&gt;
&lt;p&gt;Although Quicksort uses only &lt;em&gt;O(log n)&lt;/em&gt; stack space on the average, it can use linear space in the worst case. Explain why, then modify the program to use only logarithmic space in the worst case.&lt;/p&gt;
&lt;h1 id=&#34;problem-5&#34;&gt;Problem #5&lt;/h1&gt;
&lt;p&gt;Show how to use Lomuto&amp;rsquo;s partitioning scheme to sort varying-length bit strings in time proportion to the sum of their lengths.&lt;/p&gt;
&lt;h1 id=&#34;problem-6&#34;&gt;Problem #6&lt;/h1&gt;
&lt;p&gt;Use the techniques of this column to implement other sorting algorithms. Selection sort first places the small value in x[0], then the smallest raemaining value in x[1], and so forth. Shell sort (or &amp;ldquo;diminishing increment sort&amp;rdquo;) is like Insertion sort, but moves elements down &lt;em&gt;h&lt;/em&gt; positions rather than just one position. The value of &lt;em&gt;h&lt;/em&gt; starts large, and shrinks.&lt;/p&gt;
&lt;p&gt;Note to self: implement merge sort and timsort&lt;/p&gt;
&lt;h1 id=&#34;problem-9&#34;&gt;Problem #9&lt;/h1&gt;
&lt;p&gt;Write a program for finding the kth-smallest element in the array &lt;em&gt;x&lt;/em&gt; in O(n) expected time. Your algorithm may permute the elements of &lt;em&gt;x&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;This is the quickselect algorithm.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Programming Pearls: Chapter 10</title>
       <link>https://selavy.github.io/posts/prog-pearls-ch10/</link>
       <pubDate>Fri, 22 Feb 2019 18:30:05 -0800</pubDate>
       
       <guid>https://selavy.github.io/posts/prog-pearls-ch10/</guid>
       <description>&lt;p&gt;Problems from Column #10: Squeezing Space&lt;/p&gt;
&lt;h1 id=&#34;problem-1&#34;&gt;Problem #1&lt;/h1&gt;
&lt;p&gt;In the late 1970&amp;rsquo;s Stu Feldman build a Fortran 77 compiler that barely fit in a 64-kilobyte code space. To save space he had packed some integers in critical records into four-bit fields. When he removed the packing and stored the fields in eight bits, he found that although the data space increased by a few hundred bytes, the overall size of the program went down by several thousand bytes. Why?&lt;/p&gt;
&lt;p&gt;Likely his code became simpler so the code section decreased in size.&lt;/p&gt;
&lt;h1 id=&#34;problem-2&#34;&gt;Problem #2&lt;/h1&gt;
&lt;p&gt;How would you write a program to build the sparse-matrix data structure described in Section 10.2? Can you find other simple but space-efficient data structures for this task?&lt;/p&gt;
&lt;h1 id=&#34;problem-3&#34;&gt;Problem #3&lt;/h1&gt;
&lt;p&gt;How much total disk space does your system have? How much is currently available? How much RAM? How much RAM is typically available? Can you measure the sizes of the various caches on your system?&lt;/p&gt;
&lt;p&gt;commands to use:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;free
df
cat /proc/cpuinfo
cat /proc/meminfo
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;problem-4&#34;&gt;Problem #4&lt;/h1&gt;
&lt;p&gt;Study data in non-computer applications such as almanacs and other reference books for examples of squeezing space.&lt;/p&gt;
&lt;h1 id=&#34;problem-5&#34;&gt;Problem #5&lt;/h1&gt;
&lt;p&gt;In the early days of programming, Fred Brooks faced yet anothe problem of representing a large table on a small computer (beyond that in Section 10.1). He couldn&amp;rsquo;t store the entire table in an array because there was room for only a few bits for each table entry (actually, there was one decimal digit available for each entry &amp;ndash; I said that it was in the early days!). His second approach was to use numerical analysis to fit a function through the table. That resulted in a function that was quite close to the true table (no entry was more than a couple of units off the true entry) and required an unnoticeably small amount of memory, but legal constraints meant that the approximation wasn&amp;rsquo;t good enough. How could Brooks get the required accuracy in the limited space?&lt;/p&gt;
&lt;p&gt;Use both approaches: use the function, then keep a table of the differences to get the correct result.&lt;/p&gt;
&lt;h1 id=&#34;problem-6&#34;&gt;Problem #6&lt;/h1&gt;
&lt;p&gt;The discussion of Data Compression in Section 10.3 mentioned decoding 10a + b with / and % operations. Discuss the time and space tradeoffs involved in replacing those operations by logical operations or table lookups.&lt;/p&gt;
&lt;h1 id=&#34;problem-7&#34;&gt;Problem #7&lt;/h1&gt;
&lt;p&gt;In a common type of profiler, the value of the program counter is sampled on a regular basis. Design a data structure for storing those values that is efficient in time and space and also provides useful output.&lt;/p&gt;
&lt;h1 id=&#34;problem-8&#34;&gt;Problem #8&lt;/h1&gt;
&lt;p&gt;Obvious data representations allocate eight bytes for a date (MMDDYYYY), nine bytes for social security number (DDD-DD-DDDD), and 25 bytes for a name (14 for last, 10 for first, and 1 for middle initial). If space is critical, how far can you reduce those requirements?&lt;/p&gt;
&lt;h1 id=&#34;problem-9&#34;&gt;Problem #9&lt;/h1&gt;
&lt;p&gt;Compress an online dictionary of English to be as small as possible. When counting space, measure both the data file and the program that interprets the data.&lt;/p&gt;
&lt;h1 id=&#34;problem-10&#34;&gt;Problem #10&lt;/h1&gt;
&lt;p&gt;Raw sound files (such as .wav) can be compressed to .mp3 files; raw image files (such as .bmp) can be compressed to .gif or .jpg files; raw motion picture files (such as .avi) can be compressed to .mpg files. Experiment with these file formats to estimate their compression effectiveness. How effective are these special purpose compression formats when compared to general-purpose schemes (such as gzip)?&lt;/p&gt;
&lt;h1 id=&#34;problem-11&#34;&gt;Problem #11&lt;/h1&gt;
&lt;p&gt;A reader observes, &amp;ldquo;With modern programs, it&amp;rsquo;s often not the code that you write, but the code that you use that&amp;rsquo;s large.&amp;rdquo; Study your programs to see how large they are after linking. How can you reduce that space?&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Programming Pearls: Chapter 9</title>
       <link>https://selavy.github.io/posts/prog-pearls-ch9/</link>
       <pubDate>Mon, 18 Feb 2019 08:30:07 -0800</pubDate>
       
       <guid>https://selavy.github.io/posts/prog-pearls-ch9/</guid>
       <description>&lt;p&gt;Problems from Column #9: Code Tuning&lt;/p&gt;
&lt;p&gt;Note: I did skip several problems from several columns because I didn&amp;rsquo;t find them particularly useful. Several of the questions here on out are also pretty dated so I&amp;rsquo;m just going to jump around to the ones that I like.&lt;/p&gt;
&lt;h1 id=&#34;lessons&#34;&gt;Lessons&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Speed comes from knowing your data and specializing.
** This comes with what can be a huge cost in terms of maintainability. For most programs this speed is only required in a small part of the program.&lt;/li&gt;
&lt;li&gt;Profile first.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;problem-3&#34;&gt;Problem #3&lt;/h1&gt;
&lt;p&gt;What special properties of the &amp;ldquo;juggling&amp;rdquo; rotation algorithm allowed us to replace the % remainder operator with an &lt;em&gt;if&lt;/em&gt; statement, and not a more costly &lt;em&gt;while&lt;/em&gt; statement?&lt;/p&gt;
&lt;p&gt;We knew that with the given algorithm, the values would remain in the range [0, 2n) so subtracting &lt;em&gt;n&lt;/em&gt; would get us back to the range [0, n). Note: if &lt;em&gt;n&lt;/em&gt; is a power of 2, then x % n ==&amp;gt; x &amp;amp; (n-1), which likely will be faster than the &lt;em&gt;if&lt;/em&gt; statement and subtraction.&lt;/p&gt;
&lt;h1 id=&#34;problem-6&#34;&gt;Problem #6&lt;/h1&gt;
&lt;p&gt;C and C++ libraries provide character classification functions such as &lt;em&gt;isdigit&lt;/em&gt;, &lt;em&gt;isupper&lt;/em&gt;  and &lt;em&gt;islower&lt;/em&gt; to determine the types of characters. How would you implement these functions.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;This is probably more complicated with locales, and I think these functions make actually touch singleton locale data, but I&amp;rsquo;m going to ignore that. It&amp;rsquo;s just interesting if you are using them in a multi-threaded context. 2) For the simple american english ASCII case, we know that these functions only apply to signed 8-bit characters, where the MSB is 0. So I would make a 128 entry lookup table; if the upper bit is set, then return false, other LUT.&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;problem-7&#34;&gt;Problem #7&lt;/h1&gt;
&lt;p&gt;Given a very long sequence (say, billions or trillions) or bytes, how would you efficiently count the total number of one bits? (That is how many bits are turned on in the entire sequence?)&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;d build a 512-entry LUT, which would yield code like:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;Sequence bytes;
&lt;span style=&#34;color:#66d9ef&#34;&gt;uint8_t&lt;/span&gt; LUT[&lt;span style=&#34;color:#ae81ff&#34;&gt;512&lt;/span&gt;]; &lt;span style=&#34;color:#75715e&#34;&gt;// contains # of set bits in each value [0, 512)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint64_t&lt;/span&gt; count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; N; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {
    count &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; LUT[bytes[i]];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;problem-8&#34;&gt;Problem #8&lt;/h1&gt;
&lt;p&gt;How can sentinels be used in a program to find the maximum element in an array?&lt;/p&gt;
&lt;p&gt;We can avoid the i &amp;lt; N, most of the time (for many inputs), if we set the last element to INT_MAX, and only compare to INT_MAX &lt;em&gt;if&lt;/em&gt; vs[i] is greater than the current max. This saves comparisons except in the sorted inputs case, where we only added a small amount of overhead.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;find_max&lt;/span&gt;(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; vs) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; N &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vs.size();
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; hold &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vs[N&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
    vs[N&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; INT_MAX;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; INT_MIN;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; ; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {
        assert(i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; N &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sentinel failed!&amp;#34;&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (vs[i] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; result) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (vs[i] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; INT_MAX) {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
            }
            result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vs[i];
        }
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (hold &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; result) {
        result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; hold;
    }
    vs[N&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; hold;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;problem-9&#34;&gt;Problem #9&lt;/h1&gt;
&lt;p&gt;Because sequential search is simpler than binary search, it is usually more efficient for small tables. On the other hand, the logarithmic number of comparisons made by binary search implies that it will be faster than the linear time of sequential search for larger tables. The break-even point is a function of how much each program is tuned. How long and how high can you make that break-even point? What is it on your machine when both programs are equally tuned?&lt;/p&gt;
&lt;h1 id=&#34;problem-10&#34;&gt;Problem #10&lt;/h1&gt;
&lt;p&gt;D. B. Lomet observes that hashing may solve the 1000-integer search problem more efficiently than the tuned binary search. Implement a fast hashing program and compare it to the tuned binary search; how do they compare in terms of speed and space?&lt;/p&gt;
&lt;h1 id=&#34;problem-11&#34;&gt;Problem #11&lt;/h1&gt;
&lt;p&gt;In the early 1960&amp;rsquo;s, Vic Berecz found that most of the time in a simulation program at Sikorsky Aircraft was devoted to computing trigonmetric functions. Further investigation showed that the functions were computed only at integral multiples of five degrees. How did he reduce the run time?&lt;/p&gt;
&lt;p&gt;Either cache the results, or make a LUT. You only need 360 / 5 = 72 elements per function.&lt;/p&gt;
&lt;h1 id=&#34;problem-12&#34;&gt;Problem #12&lt;/h1&gt;
&lt;p&gt;One sometimes tunes programs by thinking about mathematics rather than code.&lt;/p&gt;
&lt;p&gt;To evaluate the polynomial &lt;code&gt;y = a_n*x**n + a_{n-1}*x**{n-1} + ... + a_1*x**1 + a_0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;the following code uses 2n multiplications. Give a faster function.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;y = a[0]
xi = 1
for i = [1, n]
    xi = x * xi
    y = y + a[i]*xi
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Use horner&amp;rsquo;s method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;y = a[n]
for i = [n-1 .. 1] # N.B. backwards
    y *= x
    y += a[i]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Like the usual atoi function:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;atoi&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; s) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;s) {
        result &lt;span style=&#34;color:#f92672&#34;&gt;*=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
        result &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;s&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
     </item>
   
     <item>
       <title>Programming Pearls: Chapter 4</title>
       <link>https://selavy.github.io/posts/prog-pearls-ch4/</link>
       <pubDate>Thu, 14 Feb 2019 18:51:49 -0800</pubDate>
       
       <guid>https://selavy.github.io/posts/prog-pearls-ch4/</guid>
       <description>&lt;p&gt;Problems from Column #4: Writing Correct Programs&lt;/p&gt;
&lt;h1 id=&#34;lessons&#34;&gt;Lessons&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Consider using formal verification methods on tricky functions&lt;/li&gt;
&lt;li&gt;Loop invariants are a helpful tool&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;problem-1&#34;&gt;Problem #1&lt;/h1&gt;
&lt;p&gt;As laborious as our proof of binary search was, it is still unfinished by some standards. How would you prove that the program is free of run-time errors (such as division by zero, word overflow, variables out of declared range, or array indices out of bounds)? If you have a background in discrete mathematics, can you formatlize the proof in a logical system?&lt;/p&gt;
&lt;h1 id=&#34;problem-2&#34;&gt;Problem #2&lt;/h1&gt;
&lt;p&gt;If the original binary search was too easy for you, try the variant that returns in &lt;em&gt;p&lt;/em&gt; the position of the first occurence of t in the array x (if there are multiple occurences of t, the original algorithm returns an arbitrary one). Your code should make a logarithmic number of comparisons of array elements; it is possible to do the job in log_2(n) such comparisons.&lt;/p&gt;
&lt;h1 id=&#34;problem-3&#34;&gt;Problem #3&lt;/h1&gt;
&lt;p&gt;Write and verify a recursive binary search program. Which parts of the code and proof stay the same as in the iterative version, and which parts change?&lt;/p&gt;
&lt;p&gt;First the iterative version of bsearch:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// NOTE: this is the interface that he describes in the
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// book, but a half open interval is definitely the
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// better way to code bsearch (see c++ standard lib)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bsearch&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; t, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;x, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n)
{
    &lt;span style=&#34;color:#75715e&#34;&gt;/*
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * precondition: x[0] &amp;lt;= x[1] &amp;lt;= ... &amp;lt;= x[n-1]
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     * postcondition:
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     *     result == -1    =&amp;gt; t not present in x
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     *     0 &amp;lt;= result &amp;lt; n =&amp;gt; x[result] == t
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;     */&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; l &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; u &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; m;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (l &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; u) {
		m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; l &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; ((u &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; l) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (x[m] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; t) {
            l &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; m &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (x[m] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; t) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; m;
        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; { &lt;span style=&#34;color:#75715e&#34;&gt;// x[m] &amp;gt; t
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            u &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; m &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        }
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The recursive version. Interesting note: I didn&amp;rsquo;t realize that lambdas can&amp;rsquo;t be used recursively:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;go&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; t, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;x, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; l, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; u)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (l &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; u)        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; l &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; ((u &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; l) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (x[m] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; t)       &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; go(t, x, m&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, u);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (x[m] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; t) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; m;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; go(t, x, l, m&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bsearch_recursive&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; t, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;x, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n) { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; go(t, x, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, n&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;); }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;problem-4&#34;&gt;Problem #4&lt;/h1&gt;
&lt;p&gt;Add fictitious &amp;ldquo;timing variables&amp;rdquo; to your binary search program to count the number of comparisons it makes, and use program verification techniques to prove that its run time is indeed logarithmic.&lt;/p&gt;
&lt;h1 id=&#34;problem-5&#34;&gt;Problem #5&lt;/h1&gt;
&lt;p&gt;Prove that this program terminates when its input &lt;em&gt;x&lt;/em&gt; is a positive integer.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while x != 1 do
    if even(x)
        x = x/2
    else
        x = 3*x+1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The hint for this problem says, &amp;ldquo;If you solve this problem, run to the nearest mathematics department and ask for a Ph.D.&amp;quot;. So going to wait on this solution.&lt;/p&gt;
&lt;h1 id=&#34;problem-6&#34;&gt;Problem #6&lt;/h1&gt;
&lt;p&gt;David Gries calls this the &amp;ldquo;Coffee Can Problem&amp;rdquo; in his &lt;em&gt;Science of Programming&lt;/em&gt;. You are initially given a coffee can that contains some black beans and some white beans and a large pile of &amp;ldquo;extra&amp;rdquo; black beans. You then repeat the following process until there is a single bean left in the can.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Randomly select two beans from the can.
If they are the same color:
    throw them both out and insert an extra black bean.
If they are different colors:
    return the white bean to the can and throw out the black.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Prove that the process terminates. What can you say about the color of the final remaining bean as a function of the number of black and white beans originally in the can?&lt;/p&gt;
&lt;p&gt;If even white, then black final bean.&lt;/p&gt;
&lt;h1 id=&#34;problem-7&#34;&gt;Problem #7&lt;/h1&gt;
&lt;p&gt;A colleague faced the following problem in a program to draw lines on a bit-mapped display. An array of &lt;em&gt;n&lt;/em&gt; pairs of reals (a_i, b_i) defined the &lt;em&gt;n&lt;/em&gt; lines y_i = a_i*x + b_i. The lines were ordered in the x-iunterval [0, 1] in the sense that y_i &amp;lt; y_{i+1} for all values of *i* between 0 and n-2 and all values of *x* in [0,1]. Less formally, the lines don&amp;rsquo;t touch in the vertical slab. Given a point (x,y), where 0&amp;lt;=x&amp;lt;=1, he wanted to determine the two lines that bracket the point. How could he solve the problem quickly?&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s not clear what to do if the given point is above the top line or below the bottom line, but this is covers the common case:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Iter&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Iter, Iter&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; find_line(Iter first, Iter last, &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; x, &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; y)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; compare &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [x](&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; y, std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; p) &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; (x&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;p.first &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; p.second);
    };
    &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; hi &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;upper_bound(first, last, y, compare);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;make_pair(hi &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, hi);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;problem-8&#34;&gt;Problem #8&lt;/h1&gt;
&lt;p&gt;Binary search is fundamentally faster than sequential search: to search an &lt;em&gt;n&lt;/em&gt;-element table, it makes roughtly log_{2}(n) comparisons while sequential search makes roughly n/2. While it is often fast enough, in a few cases binary search must be made faster yet. Although you can&amp;rsquo;t reduce the logarithmic number of comparisons made by the algorithm, can you rewrite the binary search code to be faster? For definiteness, assume that you are to search a sorted table of n=1000 integers.&lt;/p&gt;
&lt;h1 id=&#34;problem-9&#34;&gt;Problem #9&lt;/h1&gt;
&lt;p&gt;As exercises in program verification, precisely specify the input/output behavior of each of the following program fragments and show that the code meets its specification. The first program implements the vector addition a = b + c.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;i = 0
while i &amp;lt; n
    a[i] = b[i] + c[i]
    i = i + 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;input: array b with length n
array c with length n
output array a with length n
output: array a s.t. a[i] = b[i] + c[i]&lt;/p&gt;
&lt;h3 id=&#34;inline-answer&#34;&gt;Inline Answer&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;i = 0
while i &amp;lt; n
    assert i in range(0, n-1)
    a[i] = b[i] + c[i]
    assert a[i] = b[i] + c[i] (as desired)
assert i = n, therefore all indices were visited
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This function is so straightforward, I&amp;rsquo;m not really sure what kind of proof is necessary&amp;hellip; The only thing really to prove is that i visits all values in the range [0, n-1], which proven by inspection.&lt;/p&gt;
&lt;p&gt;(This code and the next two fragments expand the for i=[0, n) loop to a while loop with an increment at the end.) The next fragment computes the maximum value in the array &lt;em&gt;x&lt;/em&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;max = x[0]
i = 1
while i &amp;lt; n do
    if x[i] &amp;gt; max
        max = x[i]
    i = i + 1
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;inline-answer-1&#34;&gt;Inline Answer&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;max = x[0]
i = 1
while i &amp;lt; n do
    assert i in range(1, n-1)
    assert x is max element in range(0, i-1)
    if x[i] &amp;gt; max
        max = x[i]
    i = i + 1
assert i = n, therefore all indicies 0 .. n-1 were visited
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I think the key here is the pre-condition that x is max element in the range(0, i-1) at every step, then via proof by induction by we can see that x will be the max value when the loop exits.&lt;/p&gt;
&lt;p&gt;This sequential search program returns the position of the first occurrence of &lt;em&gt;t&lt;/em&gt; in the array x[0..n-1].&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;i = 0
while i &amp;lt; n &amp;amp;&amp;amp; x[i] != t
    i = i+1
if i &amp;gt;= n
    p = -1
else
    p = i
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;inline-answer-2&#34;&gt;Inline Answer&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;i = 0
while i &amp;lt; n &amp;amp;&amp;amp; x[i] != t
    assert t not in range(0, i)
assert t == x[i] or t not in x
if i &amp;gt;= n
    assert t not in x
    return -1
else
    p = i
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The loop invariant is &amp;ldquo;t not in range(0, i)&amp;quot;, and we visit all values of i in the range [0, n).&lt;/p&gt;
&lt;p&gt;This program computes the n-th power of x in time proportional to the logarithm of &lt;em&gt;n&lt;/em&gt;. This recursive program is straightforward to code and to verify; the iterative version is subtle, and is left as an additional problem.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function exp(x, n)
        pre n &amp;gt;= 0
        post result = x^n
    if n = 0
        return 1
    else if even(n)
        return square(exp(x, n/2))
    else
        return x*exp(x, n-1)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;inline-answer-3&#34;&gt;Inline Answer&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;function exp(x, n)
        pre n &amp;gt;= 0
        post result = x^n
    if n = 0
        return 1
    else if even(n)
        assert n % 2 == 0
        assert x^n == x^(n/2)^2
        return square(exp(x, n/2))
    else
        assert x^n == x*(x^(n-1))
        return x*exp(x, n-1)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The loop invariant is result = x^n, which we will decompose until n = 0, at which point we know x^0 = 1. The only thing to really prove is that n will reach 0: since on each iteration either n -&amp;gt; floor(n/2) or n -&amp;gt; n - 1, n will eventually reach 0.&lt;/p&gt;
&lt;p&gt;The iterative version of this function is:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;exp&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (;;) {
        &lt;span style=&#34;color:#75715e&#34;&gt;// loop invariant: exp = x^n
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (n &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
            result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; result &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; x;
        }
        n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (n &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
        }
        x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; x;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;problem-10&#34;&gt;Problem #10&lt;/h1&gt;
&lt;p&gt;Introduce errors into the binary search function and see whether (and how) they are caught by attempting to verify the buggy code.&lt;/p&gt;
&lt;h1 id=&#34;problem-11&#34;&gt;Problem #11&lt;/h1&gt;
&lt;p&gt;Write and prove the correctness of a recursive binary search in C or C++ with this declaration:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int binarysearch(DataType x[], int n)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Use this function alone; do not call any other recursive functions.&lt;/p&gt;
&lt;p&gt;It is not at all clear to me what this question is asking. The way the function signature is written, it doesn&amp;rsquo;t even take the element that we are searching for. For the recursive binary search, see solution to problem #3.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Programming Pearls: Chapter 3</title>
       <link>https://selavy.github.io/posts/prog-pearls-ch3/</link>
       <pubDate>Thu, 31 Jan 2019 20:28:30 -0800</pubDate>
       
       <guid>https://selavy.github.io/posts/prog-pearls-ch3/</guid>
       <description>&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Problems from Column #3: Data Structures Programs&lt;/p&gt;
&lt;h1 id=&#34;lessons&#34;&gt;Lessons&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Proper view of data structures programs
** The data a system is to process gives deep insight into a good module structure
** Understand the input, the output, and the intermediate data structures&lt;/li&gt;
&lt;li&gt;Separate data from control (e.g. Model+View+Controller)&lt;/li&gt;
&lt;li&gt;Don&amp;rsquo;t write a big program when a little one will do
** The more general problem may be easier to solve (Polya&amp;rsquo;s &amp;ldquo;Inventor&amp;rsquo;s Paradox&amp;rdquo;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;problem-1&#34;&gt;Problem #1&lt;/h1&gt;
&lt;p&gt;As the second edition of this book goes to press, individual income in the United States is taxed at five different rates, the maximum of which is around forty percent. The situation was formerly more complicated, and more expensive. A programming text the following twenty-five &lt;em&gt;if&lt;/em&gt; statements as a reasonable approach for calculating the 1978 United States Federal Income Tax. The rate sequence .14, .15, .16, .17, .18, &amp;hellip; exhibits jumps larger than .01 later in the sequence. Any comments?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if income &amp;lt;= 2200
    tax = 0
else if income &amp;lt;= 2700
    tax =         .14 * (income - 2200)
else if income &amp;lt;= 3200
    tax =    70 + .15 * (income - 2700)
else if income &amp;lt;= 3700
    tax =   145 + .16 * (income - 3200)
else if income &amp;lt;= 4200
    tax =   225 + .17 * (income - 3700)
    ...
else
    tax = 53090 + .70 * (income - 102200)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;First thing to notice is that every calculation can be formulated as &lt;code&gt;tax = base[i] + rate[i] * (income - offset[i])&lt;/code&gt;. So the easiest solution is to set up a table of&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Limit&lt;/th&gt;
&lt;th&gt;Base&lt;/th&gt;
&lt;th&gt;Rate&lt;/th&gt;
&lt;th&gt;Offset&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2200&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2700&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;.14&lt;/td&gt;
&lt;td&gt;2200&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3200&lt;/td&gt;
&lt;td&gt;70&lt;/td&gt;
&lt;td&gt;.15&lt;/td&gt;
&lt;td&gt;2700&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3700&lt;/td&gt;
&lt;td&gt;145&lt;/td&gt;
&lt;td&gt;.16&lt;/td&gt;
&lt;td&gt;3200&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4200&lt;/td&gt;
&lt;td&gt;225&lt;/td&gt;
&lt;td&gt;.17&lt;/td&gt;
&lt;td&gt;3700&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INT_MAX&lt;/td&gt;
&lt;td&gt;53090&lt;/td&gt;
&lt;td&gt;.70&lt;/td&gt;
&lt;td&gt;102200&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Then we can just scan through the table:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for i in 0 .. len(table):
    if income &amp;lt;= limit[i]:
        tax = base[i] + rate[i] * (income - offset[i])
        break
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It does look like the offset value is always the previous row&amp;rsquo;s limit, so you could be more sophisticate about it.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Limit&lt;/th&gt;
&lt;th&gt;Base&lt;/th&gt;
&lt;th&gt;Rate&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2200&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2700&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;.14&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3200&lt;/td&gt;
&lt;td&gt;70&lt;/td&gt;
&lt;td&gt;.15&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3700&lt;/td&gt;
&lt;td&gt;145&lt;/td&gt;
&lt;td&gt;.16&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4200&lt;/td&gt;
&lt;td&gt;225&lt;/td&gt;
&lt;td&gt;.17&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INT_MAX&lt;/td&gt;
&lt;td&gt;53090&lt;/td&gt;
&lt;td&gt;.70&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;for i in 1 .. len(table)
    if income &amp;lt;= limit[i]:
        tax = base[i] + rate[i] * (income - limit[i-1)
        break
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;problem-2&#34;&gt;Problem #2&lt;/h1&gt;
&lt;p&gt;A &lt;em&gt;k-th&lt;/em&gt; order linear recurrence with constant coefficients defines a series as:&lt;/p&gt;
&lt;p&gt;$$ a_n = c_1&lt;em&gt;a_{n-1} + c_2&lt;/em&gt;a_{n-2} + &amp;hellip; + c_k*a_{n-k} + c_{k+1}$$,&lt;/p&gt;
&lt;p&gt;where \(c_1, &amp;hellip;, c_{k+1}\) are real numbers. Write a program that with input \(k, a_1, &amp;hellip;, a_k, c_1, &amp;hellip;, c_{k+1} \), and &lt;em&gt;m&lt;/em&gt; produces the output \(a_1\) through \(a_m\). How difficult is that program compared to a program that evaluates one particular fifth-order recurrence, but does so without using arrays?&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;recurrence&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; K, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; M, &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; c) &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; K; n &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; M; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;n) {
        a[n] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; c[K];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; K; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {
            a[n] &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; a[n&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;c[i];
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Another solution (not really convinced it is better&amp;hellip;):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; Real &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;size_t K&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; Reals &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;array&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Real, K&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; K, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; M&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
Reals&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;M&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; recurrence(Reals&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;K&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; as, Reals&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;K&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; cs) &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt;
{
    Reals&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;M&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; output;
    memcpy(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;output[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;], &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;as[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;], &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(as[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;])&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;K);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; K; n &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; M; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;n) {
        &lt;span style=&#34;color:#75715e&#34;&gt;// Calculate the new value
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        Real r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cs[K];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; K; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {
            r &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; as[K&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;cs[i];
        }
        &lt;span style=&#34;color:#75715e&#34;&gt;// Propogate the values backward
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; K&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {
            as[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; as[i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
        }
        as[K&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; r;
        output[n] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; r;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; output;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;problem-3&#34;&gt;Problem #3&lt;/h1&gt;
&lt;p&gt;Write a &amp;ldquo;banner&amp;rdquo; function that is given a capital letter as input and produces as output an array of character that graphically depicts that letter.&lt;/p&gt;
&lt;p&gt;Would just make an array, and index that for each input.&lt;/p&gt;
&lt;h1 id=&#34;problem-4&#34;&gt;Problem #4&lt;/h1&gt;
&lt;p&gt;Write functions for the following date problems: given two dates, compute the number of days between them; given a date, return its day of the week; given a month and year, produce a calendar for the month as an array of characters.&lt;/p&gt;
&lt;p&gt;To do this without the system utilities is actually a huge PITA. But you can use the &lt;code&gt;cal&lt;/code&gt; command :)&lt;/p&gt;
&lt;h1 id=&#34;problem-5&#34;&gt;Problem #5&lt;/h1&gt;
&lt;p&gt;This problem deals with a small part of the problem of hyphenating English words. The following list of rules describes some legal hyphenations of words that end in the letter &amp;ldquo;c&amp;rdquo;
:&lt;/p&gt;
&lt;p&gt;et-ic al-is-tic s-tic p-tic -lyt-ic ot-ic an-tic n-tic c-tic at-ic h-nic n-ic m-ic l-lib b-lic -clic l-ic h-ic f-ic d-ic -bic a-ic -mac i-ac&lt;/p&gt;
&lt;p&gt;The rules must be applied in the above order; thus the hyphenations &amp;ldquo;eth-nic&amp;rdquo; (which is caught by the rule &amp;ldquo;h-nic&amp;rdquo;) and &amp;ldquo;clinic&amp;rdquo; (which fails that test and falls through to &amp;ldquo;n-ic&amp;rdquo;). How would you represent such rules in a function that is given a word and must return suffix hyphenations?&lt;/p&gt;
&lt;h1 id=&#34;problem-6&#34;&gt;Problem #6&lt;/h1&gt;
&lt;p&gt;Build a &amp;ldquo;form-letter generator&amp;rdquo; that can prepare a customized document for each record in a database (this is often referred to as a &amp;ldquo;mail-merge&amp;rdquo; feature). Design small schemas and input files to test the correctness of your program.&lt;/p&gt;
&lt;p&gt;Use jinja.&lt;/p&gt;
&lt;h1 id=&#34;problem-7&#34;&gt;Problem #7&lt;/h1&gt;
&lt;p&gt;Typical dictionaries allow one to look up the definition of a word, and Problem 2.1 describes a dictionary that allows one to look up the anagrams of a word. Design dictionaries for looking up the proper spelling of a word and for looking up the rhymes of a word. Discuss dictionaries for looking up an integer sequence (such as 1, 1, 2, 3, 5, 8, 13, 21, &amp;hellip;), a chemical sturcture, or the metrical structure of a song.&lt;/p&gt;
&lt;h1 id=&#34;problem-8&#34;&gt;Problem #8&lt;/h1&gt;
&lt;p&gt;[S. C. Johnson] Seven-segment devices provide an inexpensive display of the ten decimal digits: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9.
The seven segments are usually numbered as:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://selavy.github.io/img/seven_segment_display.png&#34; alt=&#34;Seven Segment Display figure&#34;&gt;&lt;/p&gt;
&lt;p&gt;Write a program that displays a 16-bit positive integer in five seven-segment digits. the ouput is an rray of five bytes; bit &lt;em&gt;i&lt;/em&gt; of byte &lt;em&gt;j&lt;/em&gt; is one if and only if the &lt;em&gt;i-th&lt;/em&gt; segment of digit &lt;em&gt;j&lt;/em&gt; should be on.&lt;/p&gt;
&lt;p&gt;I would again just have a pre-built array of 10 uint8_t where each bit set indicates if the line is on. Then I would do an algorithm like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n = &amp;lt;input&amp;gt; base = 10000
while base &amp;gt; 0:
    digit = n // base
    print(digit_to_segments[digit])
    n = n % base
    base = base / 10
&lt;/code&gt;&lt;/pre&gt;</description>
     </item>
   
     <item>
       <title>Programming Pearls: Chapter 2</title>
       <link>https://selavy.github.io/posts/prog-pearls-ch2/</link>
       <pubDate>Tue, 22 Jan 2019 19:01:57 -0800</pubDate>
       
       <guid>https://selavy.github.io/posts/prog-pearls-ch2/</guid>
       <description>&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Problems for Column #2: &amp;ldquo;Aha! Algorithms&amp;rdquo;&lt;/p&gt;
&lt;h1 id=&#34;lessons&#34;&gt;Lessons&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Break problem down into primitives for which there are known algorithms.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;A Problem Solver&amp;rsquo;s Perspective&amp;rdquo;: Good programmers are a little bit lazy: they sit back and wait for an insight rather than rushing forward with their first idea.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;problem-1&#34;&gt;Problem #1&lt;/h1&gt;
&lt;p&gt;Consider the problem of finding all the anagrams of a given input word. How would you solve this problem given only the word and the dictionary? What if you could spend some time and space to process the dictionary before answering any queries?&lt;/p&gt;
&lt;p&gt;The key is to generate a hash for each word that is the same regardless of order of the letters so that anagrams will hash to the same value. The most straightforward solution is to sort the letters.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; Dictionary &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; Dictionary dict &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;deposit&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;dopiest&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;posited&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;topside&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;peter&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;word&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sail&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;smile&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ant&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;tan&amp;#34;&lt;/span&gt;,
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; sign &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [](std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string w) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string {
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;sort(w.begin(), w.end());
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; w;
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; Anagrams &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;;

Anagrams &lt;span style=&#34;color:#a6e22e&#34;&gt;find_anagrams&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; Dicionary&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; dict, std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string word)
{
    Anagrams anagrams;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string sig &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sign(word);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; w: dict) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (sig &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; sign(w)) {
            anagrams.push_back(w);
        }
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; anagrams; &lt;span style=&#34;color:#75715e&#34;&gt;// NOTE: should get NRVO
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If you can preprocess the data, then it is worth setting up a map of Hash -&amp;gt; Vector[Words]. Then you can find the anagrams in O(1).&lt;/p&gt;
&lt;h1 id=&#34;problem-2&#34;&gt;Problem #2&lt;/h1&gt;
&lt;p&gt;Given a sequential file containing 4,300,000,000 32-bit integers, how can you find one that appears at least twice?&lt;/p&gt;
&lt;p&gt;4.3 TB * 4B ~= 16TB so we can&amp;rsquo;t hold all the values in memory. First sort the integers (probably using merge sort).  Then, traverse the integers and look for any values that are equal to the previous value.&lt;/p&gt;
&lt;h1 id=&#34;problem-3&#34;&gt;Problem #3&lt;/h1&gt;
&lt;p&gt;We skimmed two vector rotation algorithms that require subtle code; implement each as a program.  How does the greatest common divisor of i and n appear in each program?&lt;/p&gt;
&lt;h2 id=&#34;rotate-implementation&#34;&gt;Rotate implementation:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++ Technique: Use a tag to dispatch to different implementations of your algorithmn based on what iterator concept you&amp;rsquo;ve been passed.&lt;/li&gt;
&lt;li&gt;C++ Technique: STL has a std::iter_swap(), which makes several of these algorithms much cleaner.&lt;/li&gt;
&lt;li&gt;Comment: C++ function signatures are getting so noisy, especially when you have attribute like [[nodiscard]], constexpr, and conditional noexcept.
&lt;ul&gt;
&lt;li&gt;I&amp;rsquo;m still trying to find a formatting style that I like for this.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; my {

&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; BidirectionalIt&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; reverse(BidirectionalIt first,
             BidirectionalIt last,
             std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;bidirectional_iterator_tag
             ) &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt;(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;iter_swap(first, last)))
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; ((first &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; last) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; (first &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;last)) {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;iter_swap(first&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;, last);
    }
}


&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; RandomAccessIt&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; reverse(RandomAccessIt first, RandomAccessIt last,
             std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;random_access_iterator_tag
             ) &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt;(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;iter_swap(first, last)))
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (first &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; last) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (first &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;last) {
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;iter_swap(first&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;, last);
    }
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; BidirectionalIt&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; reverse(BidirectionalIt first,
             BidirectionalIt last
             ) &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt;(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;iter_swap(first, last)))
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; iterator_category &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;iterator_traits&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;BidirectionalIt&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;iterator_category;
    reverse(first, last, iterator_category());
}

} &lt;span style=&#34;color:#75715e&#34;&gt;// namespace my
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;rotate-implementation-1-using-rotate&#34;&gt;Rotate Implementation #1: using rotate&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;BidirectionalIt&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; rotate(BidirectionalIt first,
            BidirectionalIt n_first,
            BidirectionalIt last
            ) &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt;(my&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;reverse(first, n_first)))
{
    my&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;reverse(first, n_first);
    my&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;reverse(n_first, last);
    my&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;reverse(first, last);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;rotate-implementation-2-shufflin&#34;&gt;Rotate Implementation #2: shufflin&amp;rsquo;&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;I&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
I gcd(I m, I n) &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt;
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (n &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
        I t &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; m &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; n;
        m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; n;
        n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; t;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; m;
}

&lt;span style=&#34;color:#75715e&#34;&gt;// NOTE: Only works for random access iterators
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;It&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; rotate2(It first, It n_first, It last) &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt;
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; Distance &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;iterator_traits&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;It&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;difference_type;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; ValueType &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;iterator_traits&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;It&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;value_type;

    Distance n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; last &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; first;
    Distance i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; n_first &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; first;
    Distance cycles &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; gcd(i, n);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (Distance u &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; u &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; cycles; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;u) {
        Distance j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; u;
        Distance k &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; i;
        Distance z &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; n;
        ValueType t &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(first &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; u);
        &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(first &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; u) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(first &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; j);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;do&lt;/span&gt; {
            &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(first &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; j) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(first &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; z);
            j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; z;
            k &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; i;
            z &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; n;
        } &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (z &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; u);
        &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(first &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; j) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; t;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In this algorithm, gcd gives the number of shuffles that are required. Note, that the STL has implementations for std::forward_iterator as well.&lt;/p&gt;
&lt;h1 id=&#34;problem-4&#34;&gt;Problem 4&lt;/h1&gt;
&lt;p&gt;Several readers pointed out that while all three rotation algorithm require time proportional to n, the juggling algorithm is apparently twice as fast as the revresal algorithm: it stores and retrieves each element of the array just once, while the reversal algorithm does so twice. Experiment with the functions to compare their speeds to real machines; be especially sensitive to issues surrounding the locality of memory references.&lt;/p&gt;
&lt;h1 id=&#34;problem-5&#34;&gt;Problem 5&lt;/h1&gt;
&lt;p&gt;Vector rotation functions change the vector &lt;em&gt;ab&lt;/em&gt; to &lt;em&gt;ba&lt;/em&gt;; how would you transform the vector &lt;em&gt;abc&lt;/em&gt; to &lt;em&gt;cba&lt;/em&gt;? (This models the problem of swapping nonadjacent blocks of memory).&lt;/p&gt;
&lt;p&gt;Use the fact that $$(abc)^r = (a^rb^rc^r)^r$$&lt;/p&gt;
&lt;h1 id=&#34;problem-6&#34;&gt;Problem 6&lt;/h1&gt;
&lt;p&gt;In the late 1970&amp;rsquo;s, Bell Labs deployed a &amp;ldquo;user-operated directory assistance&amp;rdquo; program that allowed employeeds to look up a number in a company telephone directory using a standard push-button telephone.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://selavy.github.io/img/push_button_telephone.png&#34; alt=&#34;Push Button Telephone image&#34;&gt;&lt;/p&gt;
&lt;p&gt;This problem is solved just like the anagram problem.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// NOTE: other time vs. space tradeoffs exist, could build full
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//       256 entry to avoid AND and sub
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; ButtonMap[&lt;span style=&#34;color:#ae81ff&#34;&gt;64&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;3&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;3&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;3&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;4&amp;#39;&lt;/span&gt;,
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;4&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;4&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;5&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;5&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;5&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;6&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;6&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;6&amp;#39;&lt;/span&gt;,
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;7&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;7&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;7&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;7&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;8&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;8&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;8&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;9&amp;#39;&lt;/span&gt;,
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;9&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;9&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;9&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;,
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;3&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;3&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;3&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;4&amp;#39;&lt;/span&gt;,
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;4&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;4&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;5&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;5&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;5&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;6&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;6&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;6&amp;#39;&lt;/span&gt;,
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;7&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;7&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;7&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;7&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;8&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;8&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;8&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;9&amp;#39;&lt;/span&gt;,
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;9&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;9&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;9&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;,
};

&lt;span style=&#34;color:#a6e22e&#34;&gt;[[nodiscard]]&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; Lookup(&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; c) &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt;
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ButtonMap[(c &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x7F&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;64&lt;/span&gt;]; &lt;span style=&#34;color:#75715e&#34;&gt;// to be safe, clear the top bit
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}

&lt;span style=&#34;color:#a6e22e&#34;&gt;[[nodiscard]]&lt;/span&gt;
std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string telesign(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string first, std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string last) &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt;
{
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string rv;
    rv.reserve(last.size() &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; c: last) {
        rv &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; Lookup3(c);
    }
    rv &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;*&amp;#39;&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;first.empty()) {
        rv &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; Lookup(first[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]);
    }
    rv &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;*&amp;#39;&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; rv;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;problem-7&#34;&gt;Problem 7&lt;/h1&gt;
&lt;p&gt;In the early 1960&amp;rsquo;s, Vic Vyssotsky worked with a programmer who had to transpose a 4000-by-4000 matrix stored on magnetic tape (each record had the same format in several dozen bytes). The original program his colleague suggested would have taken fifty hours to run; how did Vyssotsky reduce the run time to half an hour?&lt;/p&gt;
&lt;p&gt;Answer given in book: If matrix is row-major, then prepend the column and row to each element, sort, remove the column and row.&lt;/p&gt;
&lt;h1 id=&#34;problem-8&#34;&gt;Problem 8&lt;/h1&gt;
&lt;p&gt;[J. Ullman] Given a set of &lt;em&gt;n&lt;/em&gt; real numbers, a real number &lt;em&gt;t&lt;/em&gt;, and an integer &lt;em&gt;k&lt;/em&gt;, how quickly can you determine whether there exists a k-element subset of the set that sums to at most &lt;em&gt;t&lt;/em&gt;?&lt;/p&gt;
&lt;p&gt;Sum the smallest &lt;em&gt;k&lt;/em&gt; elements in the set and compare to &lt;em&gt;t&lt;/em&gt;.  Should be able to use quick select, but could just use sort then choose &lt;em&gt;k&lt;/em&gt; elements.&lt;/p&gt;
&lt;h1 id=&#34;problem-9&#34;&gt;Problem 9&lt;/h1&gt;
&lt;p&gt;Sequential search and binary search represent a tradeoff between search time and preprocessing time. How many binary searches need be performed in an &lt;em&gt;n&lt;/em&gt;-element table to buy back the preprocessing time required to sort the table?&lt;/p&gt;
&lt;p&gt;Sorting is O(nlog(n)), Linear search is O(n), Binary Search is O(log(n)).&lt;/p&gt;
&lt;p&gt;$$s = Searches Needed$$&lt;/p&gt;
&lt;p&gt;$$s&lt;em&gt;lg(n) + n&lt;/em&gt;lg(n) &amp;lt; s*n$$&lt;/p&gt;
&lt;p&gt;$$n&lt;em&gt;lg(n) &amp;lt; s&lt;/em&gt;n - s*lg(n)$$&lt;/p&gt;
&lt;p&gt;$$s &amp;gt; n*lg(n)/(n-lg(n))$$&lt;/p&gt;
&lt;p&gt;Need O(n*lg(n) / (n - lg(n))) searches to make it worth it (ignoring constant factors, which is probably not correct).&lt;/p&gt;
&lt;h1 id=&#34;problem-10&#34;&gt;Problem 10&lt;/h1&gt;
&lt;p&gt;On the day a new research reported to work for Thomas Edison, Edison asked him to compute the volume of an empty light bulb shell. After several hours with calipers and calculus, the fresh hire returned with the answer of 150 cubic centimeters. In a few seconds, Edison computed and responded &amp;ldquo;closer to 155&amp;rdquo; &amp;ndash; how did he do it?&lt;/p&gt;
&lt;p&gt;Fill the light bulb with water.&lt;/p&gt;
</description>
     </item>
   
     <item>
       <title>Programming Pearls: Chapter 1</title>
       <link>https://selavy.github.io/posts/prog-pearls-ch1/</link>
       <pubDate>Sat, 19 Jan 2019 20:47:53 -0800</pubDate>
       
       <guid>https://selavy.github.io/posts/prog-pearls-ch1/</guid>
       <description>&lt;p&gt;Some notes and solutions to the Column #1: &amp;ldquo;Cracking the Oyster&amp;rdquo; in Programming Pearls by Jon Bentley.&lt;/p&gt;
&lt;h1 id=&#34;lessons&#34;&gt;Lessons&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Ask the right question. Similar to &lt;a href=&#34;https://en.wikipedia.org/wiki/5_Whys&#34;&gt;&amp;ldquo;5 Whys&amp;rdquo;&lt;/a&gt;; make sure you understand the real problem.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Look for simple designs&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;A designer knows he has arrived at perfection now when there is no longer anything to add, but when there is no longer anything to take away.&amp;rdquo; &amp;ndash; Antoine de Saint-Exupéry&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;problem-1&#34;&gt;Problem #1&lt;/h1&gt;
&lt;p&gt;Q: If memory were not scarce, how would you implement a sort in a language with libraries for representing and sorting sets?&lt;/p&gt;
&lt;p&gt;This solution only works if no duplicates or don&amp;rsquo;t care about them, but actually mirrors the solution that Jon gives so I think the question is poorly worded.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; set_sort(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; input)
{
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;set&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; s;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; v: input) {
        s.insert(v);
    }
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; rv;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; v: s) {
        rv.push_back(v);
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; rv;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;problem-2&#34;&gt;Problem #2&lt;/h1&gt;
&lt;p&gt;Q: How would you implement bit vectors using bitwise logical operators (such as and, or and shift)?&lt;/p&gt;
&lt;p&gt;In a C-style:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;[[nodiscard]]&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint32_t&lt;/span&gt; make_mask(size_t bit) &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt;
{
    assert(bit &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static_cast&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint32_t&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1u&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; bit;
}

&lt;span style=&#34;color:#a6e22e&#34;&gt;[[nodiscard]]&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint32_t&lt;/span&gt; setbit(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint32_t&lt;/span&gt; bitfield, size_t bit) &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt;
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; bitfield &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; make_mask(bit);
}

&lt;span style=&#34;color:#a6e22e&#34;&gt;[[nodiscard]]&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint32_t&lt;/span&gt; clearbit(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint32_t&lt;/span&gt; bitfield, size_t bit) &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt;
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; bitfield &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt;make_mask(bit);
}

&lt;span style=&#34;color:#a6e22e&#34;&gt;[[nodiscard]]&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; isset(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint32_t&lt;/span&gt; bitfield, size_t bit) &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt;
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (bitfield &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; make_mask(bit)) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In C++-style, which supports bitvectors that are larger than 64-bits:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; detail {

&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;size_t Bytes&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Storage&lt;/span&gt; {
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; Storage() &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; val{&lt;span style=&#34;color:#ae81ff&#34;&gt;0u&lt;/span&gt;} {}

    &lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;set&lt;/span&gt;(size_t bit) &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt;
    {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; size_t idx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bit &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; size_t off &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bit &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;;
        val[idx] &lt;span style=&#34;color:#f92672&#34;&gt;|=&lt;/span&gt; mask(off);
    }

    &lt;span style=&#34;color:#a6e22e&#34;&gt;[[nodiscard]]&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; isset(size_t bit) &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt;
    {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; size_t idx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bit &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; size_t off &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bit &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (val[idx] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; mask(off)) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0u&lt;/span&gt;;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;clear&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt;
    {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n_bytes; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {
            val[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0u&lt;/span&gt;;
        }
    }

    &lt;span style=&#34;color:#a6e22e&#34;&gt;[[nodiscard]]&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; none() &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt;
    {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n_bytes; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (val[i] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; false;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; true;
    }

    &lt;span style=&#34;color:#a6e22e&#34;&gt;[[nodiscard]]&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; all() &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt;
    {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint8_t&lt;/span&gt; allset &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint8_t&lt;/span&gt;{&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;};
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n_bytes; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (val[i] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; allset) {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; false;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; true;
    }

&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;[[nodiscard]]&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint8_t&lt;/span&gt; mask(size_t off) &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt;
    {
        assert(off &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;uint8_t&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint8_t&lt;/span&gt;{&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;} &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; off;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; size_t n_bytes &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Bytes;
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;array&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint8_t&lt;/span&gt;, n_bytes&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; val;
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;StorageBase&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; value_type &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; T;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;static_assert&lt;/span&gt;(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;is_unsigned_v&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; true, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Type must be unsigned&amp;#34;&lt;/span&gt;);

    &lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;StorageBase&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; val{&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;} {}

    &lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;set&lt;/span&gt;(size_t bit) &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt;
    {
        val &lt;span style=&#34;color:#f92672&#34;&gt;|=&lt;/span&gt; mask(bit);
    }

    &lt;span style=&#34;color:#a6e22e&#34;&gt;[[nodiscard]]&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; isset(size_t bit) &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt;
    {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (val &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; mask(bit)) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0u&lt;/span&gt;;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;clear&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt;
    {
        val &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    }

    &lt;span style=&#34;color:#a6e22e&#34;&gt;[[nodiscard]]&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; none() &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt;
    {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; val &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; value_type{&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;};
    }

    &lt;span style=&#34;color:#a6e22e&#34;&gt;[[nodiscard]]&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; all() &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt;
    {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; val &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt;value_type{&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;};
    }

&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;[[nodiscard]]&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; value_type mask(size_t off) &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt;
    {
        assert(off &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(value_type)&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; value_type{&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;} &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; off;
    }

    value_type val;
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Storage&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; StorageBase&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint8_t&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;  {};
&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Storage&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; StorageBase&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint16_t&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {};
&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Storage&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; StorageBase&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint32_t&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {};
&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Storage&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; StorageBase&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint64_t&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {};

} &lt;span style=&#34;color:#75715e&#34;&gt;// namespace detail
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;size_t MaxIndex&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;BitVector&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; detail&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Storage&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;MaxIndex &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {};

&lt;span style=&#34;color:#75715e&#34;&gt;// usage
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;TEST_CASE(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Set and clear bits first BitVector&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[column1_2]&amp;#34;&lt;/span&gt;)
{
    BitVector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; bv;
    REQUIRE(bv.isset(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; false);
    REQUIRE(bv.none() &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; true);
    REQUIRE(bv.all() &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; false);

    bv.set(&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;);
    assert(bv.isset(&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; true);
    assert(bv.isset(&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; false);
    assert(bv.none() &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; false);
    assert(bv.all() &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; false);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;problem-3&#34;&gt;Problem #3&lt;/h1&gt;
&lt;p&gt;Q: Run-time efficiency was an important part of the design goal, and the resulting program was efficient enough. Implement the bitmap sort on your system and measure its run time; how does it compare to the system sort and to the sorts in Problem 1? Assume that &lt;em&gt;n&lt;/em&gt;=10,000,000, and that the input file contains 1,000,000 integers.&lt;/p&gt;
&lt;h2 id=&#34;bitmap-sort&#34;&gt;BitMap Sort&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cstdlib&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;bit_vector.h&amp;#34; // from problem #2&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; size_t MaxValue &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10000000&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt; argv) {
    BitVector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;MaxValue&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; vec;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; val;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; input[&lt;span style=&#34;color:#ae81ff&#34;&gt;256&lt;/span&gt;];
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (fgets(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;input[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;], &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(input), stdin) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; NULL) {
        val &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; atoi(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;input[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]);
        vec.set(val);
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; MaxValue; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (vec.isset(i)) {
            printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, i);
        }
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;timings&#34;&gt;Timings&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Method&lt;/th&gt;
&lt;th&gt;Time (sec)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Debug Set Sort&lt;/td&gt;
&lt;td&gt;1.588&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Release Set Sort&lt;/td&gt;
&lt;td&gt;0.705&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Debug Bitmap Sort&lt;/td&gt;
&lt;td&gt;0.133&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Release Bitmap Sort&lt;/td&gt;
&lt;td&gt;0.118&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;System Sort&lt;/td&gt;
&lt;td&gt;0.973&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;problem-4&#34;&gt;Problem 4&lt;/h1&gt;
&lt;p&gt;If you take Problem 3 seriously, you will face the problem of generating &lt;em&gt;k&lt;/em&gt; integers less than &lt;em&gt;n&lt;/em&gt; without duplicates.  The simplest approach uses the first &lt;em&gt;k&lt;/em&gt; positive integers.  This extreme data set wo&amp;rsquo;t alter the run time of the bitmap method by much, but it might skew the run time of a system sort. How could you generate a file of k unique random integers between 0 and &lt;em&gt;n&lt;/em&gt; - 1 in random order? Strive for a short program that is also efficient.&lt;/p&gt;
&lt;h2 id=&#34;numpy-solution&#34;&gt;Numpy solution&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; numpy &lt;span style=&#34;color:#f92672&#34;&gt;as&lt;/span&gt; np

M &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10000000&lt;/span&gt;
N &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1000000&lt;/span&gt;
vals &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;random&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;choice(range(M), N, replace&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;False)
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;join([str(x) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; vals]))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;c-solution&#34;&gt;C++ Solution&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;random&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt; argv)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10000000&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1000000&lt;/span&gt;;

    &lt;span style=&#34;color:#75715e&#34;&gt;// generate numbers 0..k-1
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; range;
    range.reserve(k);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; k; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {
        range.push_back(i);
    }

    &lt;span style=&#34;color:#75715e&#34;&gt;// pick 2 random indices and swap k/2 times
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;random_device rd;
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;mt19937 gen(rd());
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;uniform_int_distribution&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; dis(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, k&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; p1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dis(gen);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; p2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dis(gen);
        std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;iter_swap(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;range[p1], &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;range[p2]);
    }

    &lt;span style=&#34;color:#75715e&#34;&gt;// take first n elements as output
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {
        printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, range[i]);
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;problem-5&#34;&gt;Problem 5&lt;/h1&gt;
&lt;p&gt;The programmer said that he had about a megabyte of free storage, but the code we sketched uses 1.25 megabytes. He was able to scrounge the extra space without much trouble. If the megabyte had been a hard and fast boundary, what would you have recommended? What is the run time of your algorithm?&lt;/p&gt;
&lt;p&gt;My initial thought is to just make multiple passes over the input file.  This technique doesn&amp;rsquo;t work if you need an online algorithm though.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cstdlib&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cstdint&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cstring&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Limit &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 1 MB
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; MaxValue &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10000000&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt; argv)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (argc &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)
    {
        fprintf(stderr, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Usage: %s &amp;lt;FILE&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, argv[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]);
        exit(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
    }

    FILE&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; fp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; fopen(argv[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;], &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;r&amp;#34;&lt;/span&gt;);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;fp)
    {
        fprintf(stderr, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Unable to open file: &amp;#39;%s&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, argv[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]);
        exit(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint32_t&lt;/span&gt; bitmap[Limit&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;];
    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; input[&lt;span style=&#34;color:#ae81ff&#34;&gt;256&lt;/span&gt;];
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; val;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; base &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; base &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; MaxValue; base &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; Limit)
    {
        rewind(fp);
        memset(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;bitmap[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;], &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(bitmap));
        &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; lo &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; base;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; hi &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; base &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; Limit;

        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (fgets(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;input[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;], &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(input), fp) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; NULL)
        {
            val &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; atoi(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;input[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;(val &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; lo &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; val &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; hi))
                &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;;
            val &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; base;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; idx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; val &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; off &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; val &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;;
            bitmap[idx] &lt;span style=&#34;color:#f92672&#34;&gt;|=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static_cast&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint32_t&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; off;
        }

        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; Limit; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i)
        {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; idx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; off &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ((bitmap[idx] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;static_cast&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;uint32_t&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; off)) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
            {
                printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; base);
            }
        }
    }

    fclose(fp);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;problem-6&#34;&gt;Problem 6&lt;/h1&gt;
&lt;p&gt;What would you recommend to the programmer if instead of saying that each integer could appear at most once, he told you that each integer could appear at most ten times? How would your solution change as a function of the amount of available storage?&lt;/p&gt;
&lt;p&gt;Idea is to keep 10 million 4-bit cells, each time a number is seen, increment the appropriate cell.&lt;/p&gt;
&lt;h2 id=&#34;implementation-1-bitfields-using-explicit-widths&#34;&gt;Implementation #1: bitfields using explicit widths&lt;/h2&gt;
&lt;p&gt;We can let the compiler generate the shifts and masks for us.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cstdlib&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cstdint&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cassert&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cinttypes&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cstring&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;memory&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; MaxValue &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10000000&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Elements &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; MaxValue &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// using 4-bits per number
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;EE&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint8_t&lt;/span&gt; lo:&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// even
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint8_t&lt;/span&gt; hi:&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// odd
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;};
&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; EE cnts[Elements];


&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt; argv) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; input[&lt;span style=&#34;color:#ae81ff&#34;&gt;256&lt;/span&gt;];
    memset(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;cnts[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;], &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(cnts));
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (fgets(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;input[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;], &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(input), stdin) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; NULL) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; val &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; atoi(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;input[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; idx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; val &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (val &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
            &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;cnts[idx].lo;
            assert(cnts[idx].lo &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;More than 10 duplicates!&amp;#34;&lt;/span&gt;);
        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
            &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;cnts[idx].hi;
            assert(cnts[idx].hi &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;More than 10 duplicates!&amp;#34;&lt;/span&gt;);
        }
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; Elements; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; p &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; cnts[i].lo; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;p) {
            printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;i);
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; p &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; cnts[i].hi; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;p) {
            printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
        }
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;implementation-2-shift-and-mask-by-hand&#34;&gt;Implementation #2: shift and mask by hand&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint8_t&lt;/span&gt; cnts[Elements];

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt; argv) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; input[&lt;span style=&#34;color:#ae81ff&#34;&gt;256&lt;/span&gt;];
    memset(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;cnts[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;], &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(cnts));
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (fgets(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;input[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;], &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(input), stdin) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; NULL) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; val &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; atoi(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;input[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; idx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; val &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;uint8_t&lt;/span&gt; lo &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (cnts[idx] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0Fu&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;uint8_t&lt;/span&gt; hi &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (cnts[idx] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0Fu&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (val &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
            &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;lo;
        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
            &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;hi;
        }
        cnts[idx] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (hi &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; (lo &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; Elements; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; lo &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (cnts[i] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0Fu&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; hi &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (cnts[i] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0Fu&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; p &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; lo; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;p) {
            printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;i);
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; p &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; hi; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;p) {
            printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
        }
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;implementation-3-safety-off&#34;&gt;Implementation #3: Safety off&lt;/h2&gt;
&lt;p&gt;Since we are storing the odd-value counters in the upper 4-bits of each byte, we can take advantage of the fact that adding 2^4 (=16) will never increment bits in the lower nibble (except in the case of overflow).  This is analogous to adding 10^x to a base 10 number; repeatedly adding 10,000 to a number will never change the bottom 4 digits.&lt;/p&gt;
&lt;p&gt;This method is slightly faster, but is less safe because we aren&amp;rsquo;t verifying that there aren&amp;rsquo;t more than 10 duplicates.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint8_t&lt;/span&gt; cnts[Elements];

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt; argv) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; input[&lt;span style=&#34;color:#ae81ff&#34;&gt;256&lt;/span&gt;];
    memset(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;cnts[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;], &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(cnts));
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (fgets(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;input[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;], &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(input), stdin) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; NULL) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; val &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; atoi(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;input[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; idx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; val &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (val &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
            cnts[idx] &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1u&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
            cnts[idx] &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1u&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;;
        }
        assert(((cnts[idx] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0F&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;More than 10 duplicates!&amp;#34;&lt;/span&gt;);
        assert(((cnts[idx] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0F&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;More than 10 duplicates!&amp;#34;&lt;/span&gt;);
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; Elements; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; lo &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (cnts[i] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0F&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; hi &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (cnts[i] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0F&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; p &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; lo; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;p) {
            printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;i);
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; p &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; hi; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;p) {
            printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
        }
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;additional-thoughts&#34;&gt;Additional Thoughts&lt;/h2&gt;
&lt;p&gt;I thought at first that it should be possible to use a struct like:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;EE&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;uint8_t&lt;/span&gt; count: &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;;
} __attribute__((packed));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;but that doesn&amp;rsquo;t appear to be the case as you can see in this &lt;a href=&#34;https://gcc.godbolt.org/z/UVcr2y&#34;&gt;Compiler Explorer&lt;/a&gt; example. I did stumble on a &lt;a href=&#34;https://github.com/gpakosz/PackedArray&#34;&gt;library&lt;/a&gt; that might help with this situation, but I didn&amp;rsquo;t really explore it.&lt;/p&gt;
&lt;h1 id=&#34;problem-7&#34;&gt;Problem 7&lt;/h1&gt;
&lt;p&gt;[R. Weil] The program as sketeched has several flaws.  The first is that it assumes that no integer appears twice in the input. What happens if one does show up more than once? How could the program be modified to call an error function in that case? What happens when an input integer is less than zero or greater than or equal to n? What if an input is not numeric? What should a program do under those circumstances? What other sanity checks could the program incorporate? Describe small data sets taht test the program, including its proper handling of these and other ill-behaved cases.&lt;/p&gt;
&lt;h1 id=&#34;problem-8&#34;&gt;Problem 8&lt;/h1&gt;
&lt;p&gt;When the programmer faced the problem, all toll-free phone numbers in the United States had the 800 area code. Toll-free codes now include 800, 877 and 888, and the list is growing. How would you sort all of the toll-free numbers using only a megabyte? How can you store a set of toll-free numbers to allow very rapid lookup to determine whether a given toll-free number is available or already taken?&lt;/p&gt;
&lt;h1 id=&#34;problem-9&#34;&gt;Problem 9&lt;/h1&gt;
&lt;p&gt;One problem with trading more space to use less time is that intializing the space can itself take a great deal of time. Show how to circumvent this problem by designing a technique to initialize an entry of a vector to zero the first time it is accessed. Your scheme should use constant time for initialization and for each vector access, and use extra space proportional to the size of the vector. Because this method reduces initialization time by using even more space, it should be considered only when space is cheap, time is dear and the vector is sparse.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Array&lt;/span&gt; {
    &lt;span style=&#34;color:#75715e&#34;&gt;// 3 parallel arrays
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; data;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; to;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; from;
    &lt;span style=&#34;color:#75715e&#34;&gt;// next available element
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; top{&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;};

    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;initialize&lt;/span&gt;(size_t i, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; value) &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt;
    {
        from[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; top;
        to[top] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i;
        data[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; value;
        &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;top;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;is_initialized&lt;/span&gt;(size_t i) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;noexcept&lt;/span&gt;
    {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; from[i] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; top &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; to[from[i]] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; i;
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;problem-10&#34;&gt;Problem 10&lt;/h1&gt;
&lt;p&gt;Before the days of low-cost overnight deliveries, a store allowed customers to order items over the telephone, which they picked up a few days later. The store&amp;rsquo;s database used the customer&amp;rsquo;s telephone number as the primary key for retrieval (customers know their phone numbers and the keys are close to unique). How would you organize the store&amp;rsquo;s database to allow orders to be inserted and retrieved efficiently?&lt;/p&gt;
&lt;p&gt;Use last n-digits as a hash.&lt;/p&gt;
&lt;h1 id=&#34;problem-11&#34;&gt;Problem 11&lt;/h1&gt;
&lt;p&gt;In the early 1980&amp;rsquo;s Lockheed engineers transmitted daily a dozen drawings from a Computer Aided Design (CAD) system in their Sunnyvale, California, plant to a test station in Santa Cruz. Although the facilities were just 25 miles apart, an automobile courier service took over an hour (due to traffic jams and mountain roads) and cost a hundred dollars per day. Propose alternative data transmission schemes and estimate their cost.&lt;/p&gt;
&lt;h1 id=&#34;problem-12&#34;&gt;Problem 12&lt;/h1&gt;
&lt;p&gt;Pioneers of human space flight soon realized the need for writing implements that work well in the extreme environment of space. A popular urban legend asserts that the United States National Aeronautics and Space Administration (NASA) solved the problem with a million dollars of research to develop a special pen. According to the legend, how did the Soviets solve the same problem?&lt;/p&gt;
&lt;p&gt;A pencil.&lt;/p&gt;
</description>
     </item>
   
 </channel>
</rss>
